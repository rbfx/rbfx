<?xml version="1.0" encoding="utf-8"?>
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">
  <!--
    This natvis file is tweaked for running using vscode on gdb/lldb debuggers on unix platforms.
    Natvis implementation on these platforms is incomplete and thus workarounds for it's limitations
    were added to this file. Functionality should mostly match rbfx.natvis. New compatible additions
    to that file will be ported into this one.

    vscode natvis implementation for unix platforms can be found at:
    https://github.com/microsoft/MIEngine/tree/master/src/MIDebugEngine/Natvis.Impl
  -->

  <!-- Urho3D::StringHash -->
  <Type Name="Urho3D::StringHash"> <!--  Priority="Low" -->
    <DisplayString>#{value_}</DisplayString>
  </Type>

  <!-- Urho3D::StringHash with hash reversing -->
  <!--Type Name="Urho3D::StringHash">
    <DisplayString Condition="!Urho3D::hashReverseMap">#{value_}</DisplayString>
    <Expand>
      <CustomListItems MaxItemsPerView="1" Condition="Urho3D::hashReverseMap">
        <Variable Name="pPtrs" InitialValue="Urho3D::hashReverseMap->ptrs_"/>
        <Variable Name="pNode" InitialValue="(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)0"/>
        <Variable Name="nBuckets" InitialValue="0"/>
        <Variable Name="nHash" InitialValue="0"/>

        <If Condition="pPtrs">
          <Exec>nBuckets = (unsigned)pPtrs[1]</Exec>
          <Exec>nHash = value_ &amp; (nBuckets - 1)</Exec>
          <Exec>pNode = (Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pPtrs[nHash + 2]</Exec>
          <Loop Condition="pNode">
            <If Condition="(*(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pNode).pair_.first_.value_ == value_">
              <Item Name="[string]">(*(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pNode).pair_.second_</Item>
              <Break/>
            </If>
            <Exec>pNode = (Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)(*pNode).down_</Exec>
          </Loop>
        </If>
        <If Condition="!pNode">
          <Item Name="[value]">value_</Item>
        </If>
      </CustomListItems>
    </Expand>
  </Type-->

  <!-- Urho3D::StringHash with hash reversing (Urho3D_d.dll) -->
  <!--Type Name="Urho3D::StringHash" Priority="MediumLow">
    <DisplayString Condition="!Urho3D_d.dll!Urho3D::hashReverseMap">#{value_}</DisplayString>
    <Expand>
      <CustomListItems MaxItemsPerView="1" Condition="Urho3D_d.dll!Urho3D::hashReverseMap">
        <Variable Name="pPtrs" InitialValue="Urho3D_d.dll!Urho3D::hashReverseMap->ptrs_"/>
        <Variable Name="pNode" InitialValue="(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)0"/>
        <Variable Name="nBuckets" InitialValue="0"/>
        <Variable Name="nHash" InitialValue="0"/>

        <If Condition="pPtrs">
          <Exec>nBuckets = (unsigned)pPtrs[1]</Exec>
          <Exec>nHash = value_ &amp; (nBuckets - 1)</Exec>
          <Exec>pNode = (Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pPtrs[nHash + 2]</Exec>
          <Loop Condition="pNode">
            <If Condition="(*(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pNode).pair_.first_.value_ == value_">
              <Item Name="[string]">(*(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pNode).pair_.second_</Item>
              <Break/>
            </If>
            <Exec>pNode = (Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)(*pNode).down_</Exec>
          </Loop>
        </If>
        <If Condition="!pNode">
          <Item Name="[value]">value_</Item>
        </If>
      </CustomListItems>
    </Expand>
  </Type-->

  <!-- Urho3D::StringHash with hash reversing (Urho3D.dll) -->
  <!--Type Name="Urho3D::StringHash" Priority="MediumLow">
    <DisplayString Condition="!Urho3D.dll!Urho3D::hashReverseMap">#{value_}</DisplayString>
    <Expand>
      <CustomListItems MaxItemsPerView="1" Condition="Urho3D.dll!Urho3D::hashReverseMap">
        <Variable Name="pPtrs" InitialValue="Urho3D.dll!Urho3D::hashReverseMap->ptrs_"/>
        <Variable Name="pNode" InitialValue="(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)0"/>
        <Variable Name="nBuckets" InitialValue="0"/>
        <Variable Name="nHash" InitialValue="0"/>

        <If Condition="pPtrs">
          <Exec>nBuckets = (unsigned)pPtrs[1]</Exec>
          <Exec>nHash = value_ &amp; (nBuckets - 1)</Exec>
          <Exec>pNode = (Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pPtrs[nHash + 2]</Exec>
          <Loop Condition="pNode">
            <If Condition="(*(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pNode).pair_.first_.value_ == value_">
              <Item Name="[string]">(*(Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)pNode).pair_.second_</Item>
              <Break/>
            </If>
            <Exec>pNode = (Urho3D::HashMap&lt;Urho3D::StringHash,Urho3D::String&gt;::Node*)(*pNode).down_</Exec>
          </Loop>
        </If>
        <If Condition="!pNode">
          <Item Name="[value]">value_</Item>
        </If>
      </CustomListItems>
    </Expand>
  </Type-->

  <!-- Urho3D::Variant -->
  <Type Name="Urho3D::Variant">
    <DisplayString Condition="type_==Urho3D::VAR_NONE">(none)</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_INT">(int) {value_.int_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_BOOL">(bool) {value_.bool_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_FLOAT">(float) {value_.float_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_VECTOR2">(vec2) {value_.vector2_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_VECTOR3">(vec3) {value_.vector3_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_VECTOR4">(vec4) {value_.vector4_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_QUATERNION">(quat) {value_.quaternion_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_COLOR">(color) {value_.color_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_DOUBLE">(double) {value_.double_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_STRING">(string) {value_.string_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_BUFFER">(string) {value_.buffer_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_VOIDPTR">(void*) {value_.voidPtr_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_RESOURCEREF">(resref) {value_.resourceRef_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_RESOURCEREFLIST">(resref) {value_.resourceRefList_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_VARIANTVECTOR">(vector) {value_.variantVector_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_VARIANTMAP">(map) {value_.variantMap_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_INTRECT">(irect) {value_.intRect_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_INTVECTOR2">(ivec2) {value_.intVector2_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_PTR">(pointer) {value_.weakPtr_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_MATRIX3">(mat3) {*value_.matrix3_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_MATRIX3X4">(mat3x4) {*value_.matrix3x4_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_MATRIX4">(mat4) {*value_.matrix4_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_DOUBLE">(double) {value_.double_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_STRINGVECTOR">(string[]) {value_.stringVector_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_RECT">(rect) {value_.rect_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_INTVECTOR3">(ivec3) {value_.intVector3_}</DisplayString>
    <DisplayString Condition="type_==Urho3D::VAR_INT64">(int64) {value_.int64_}</DisplayString>
    <!-- Add new types here -->
    <DisplayString Condition="type_==Urho3D::VAR_CUSTOM">(custom) {(*(Urho3D::CustomVariantValue*)value_.storage_)}</DisplayString>
    <Expand>
      <Item Name="[value]" Condition="type_==Urho3D::VAR_INT">value_.int_</Item>
      <Item Name="[value]" Condition="type_==Urho3D::VAR_BOOL">value_.bool_</Item>
      <Item Name="[value]" Condition="type_==Urho3D::VAR_FLOAT">value_.float_</Item>
      <ExpandedItem Condition="type_==Urho3D::VAR_VECTOR2">value_.vector2_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_VECTOR3">value_.vector3_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_VECTOR4">value_.vector4_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_QUATERNION">value_.quaternion_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_COLOR">value_.color_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_STRING">value_.string_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_BUFFER">value_.buffer_</ExpandedItem>
      <Item Name="[value]" Condition="type_==Urho3D::VAR_VOIDPTR">value_.voidPtr_</Item>
      <ExpandedItem Condition="type_==Urho3D::VAR_RESOURCEREF">value_.resourceRef_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_RESOURCEREFLIST">value_.resourceRefList_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_VARIANTVECTOR">value_.variantVector_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_VARIANTMAP">value_.variantMap_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_INTRECT">value_.intRect_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_INTVECTOR2">value_.intVector2_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_PTR">value_.weakPtr_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_MATRIX3">*value_.matrix3_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_MATRIX3X4">*value_.matrix3x4_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_MATRIX4">*value_.matrix4_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_DOUBLE">value_.double_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_STRINGVECTOR">value_.stringVector_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_RECT">value_.rect_</ExpandedItem>
      <ExpandedItem Condition="type_==Urho3D::VAR_INTVECTOR3">value_.intVector3_</ExpandedItem>
      <Item Name="[value]" Condition="type_==Urho3D::VAR_INT64">value_.int64_</Item>
      <!-- Add new types here -->
      <ExpandedItem Condition="type_==Urho3D::VAR_CUSTOM">(*(Urho3D::CustomVariantValue*)value_.storage_)</ExpandedItem>
    </Expand>
  </Type>

  <!-- Urho3D::CustomVariantValueImpl<> -->
  <Type Name = "Urho3D::CustomVariantValueImpl&lt;*&gt;">
    <DisplayString>{ value_ }</DisplayString>
    <Expand>
      <ExpandedItem>value_</ExpandedItem>
    </Expand>
  </Type>

  <!-- Urho3D::SharedPtr<> -->
  <Type Name = "Urho3D::SharedPtr&lt;*&gt;">
    <DisplayString>{ptr_}</DisplayString>
    <Expand>
      <Synthetic Condition="!ptr_" Name="[empty]"/>
      <Item Condition="ptr_" Name="[strong]">ptr_->refCount_->refs_</Item>
      <Item Condition="ptr_" Name="[weak]">ptr_->refCount_->weakRefs_</Item>
      <Item Condition="ptr_" Name="[ptr]">ptr_</Item>
    </Expand>
  </Type>

  <!-- Urho3D::WeakPtr<> -->
  <Type Name = "Urho3D::WeakPtr&lt;*&gt;">
    <DisplayString Condition="!refCount_">(empty)</DisplayString>
    <DisplayString Condition="refCount_ &amp;&amp; (refCount_->refs_ &lt; 0)">(expired)</DisplayString>
    <DisplayString Condition="refCount_ &amp;&amp; !(refCount_->refs_ &lt; 0)">{ptr_}</DisplayString>
    <Expand>
      <Synthetic Condition="!refCount_" Name="[empty]"/>
      <Synthetic Condition="refCount_ &amp;&amp; refCount_->refs_ &lt; 0" Name="[expired]"/>
      <Item Condition="refCount_" Name="[weak]">refCount_->weakRefs_</Item>
      <Item Condition="refCount_" Name="[strong]">refCount_->refs_</Item>
      <Item Condition="refCount_ &amp;&amp; !(refCount_->refs_ &lt; 0)" Name="[ptr]">ptr_</Item>
    </Expand>
  </Type>

  <!-- Urho3D::Node -->
  <Type Name = "Urho3D::Node">
    <DisplayString>name_ = {impl_.mPair.mFirst->name_}</DisplayString>
  </Type>

  <!-- Urho3D::Resource -->
  <Type Name = "Urho3D::Resource">
    <DisplayString>name_ = {name_}</DisplayString>
  </Type>



  <!-- - - - - - - - - - - - - -->
  <!-- Content of EASTL.natvis -->
  <!-- - - - - - - - - - - - - -->

  <Type Name="eastl::unique_ptr&lt;*&gt;">
    <DisplayString Condition="mPair.mFirst != nullptr">({(void*)mPair.mFirst} = {*mPair.mFirst})</DisplayString>
    <DisplayString Condition="mPair.mFirst == nullptr">({nullptr})</DisplayString>
    <Expand>
      <Item Name="[pointer]">(void*)mPair.mFirst</Item>
      <Item Name="[value]">*mPair.mFirst</Item>
    </Expand>
  </Type>

  <Type Name="eastl::shared_ptr&lt;*&gt;">
    <DisplayString Condition="mpValue != nullptr">({(void*)mpValue} = {*mpValue})</DisplayString>
    <DisplayString Condition="mpValue == nullptr">({nullptr})</DisplayString>
    <Expand>
      <Item Name="[pointer]">(void*)mpValue</Item>
      <Item Name="[value]">*mpValue</Item>
      <Item Name="[reference count]">mpRefCount->mRefCount</Item>
      <Item Name="[weak reference count]">mpRefCount->mWeakRefCount</Item>
    </Expand>
  </Type>

  <Type Name="eastl::weak_ptr&lt;*&gt;">
    <DisplayString>{((mpRefCount &amp;&amp; mpRefCount-&gt;mRefCount) ? mpValue : nullptr)}</DisplayString>
    <Expand>
      <ExpandedItem>mpRefCount &amp;&amp; mpRefCount-&gt;mRefCount ? mpValue : nullptr</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::array&lt;*,*&gt;">
    <DisplayString Condition="$T2 == 0">[{$T2}] {{}}</DisplayString>
    <DisplayString Condition="$T2 == 1">[{$T2}] {{ {*mValue} }}</DisplayString>
    <DisplayString Condition="$T2 == 2">[{$T2}] {{ {*mValue}, {*(mValue+1)} }}</DisplayString>
    <DisplayString Condition="$T2 == 3">[{$T2}] {{ {*mValue}, {*(mValue+1)}, {*(mValue+2)} }}</DisplayString>
    <DisplayString Condition="$T2 == 4">[{$T2}] {{ {*mValue}, {*(mValue+1)}, {*(mValue+2)}, {*(mValue+3)} }}</DisplayString>
    <DisplayString Condition="$T2 == 5">[{$T2}] {{ {*mValue}, {*(mValue+1)}, {*(mValue+2)}, {*(mValue+3)}, {*(mValue+4)} }}</DisplayString>
    <DisplayString Condition="$T2 == 6">[{$T2}] {{ {*mValue}, {*(mValue+1)}, {*(mValue+2)}, {*(mValue+3)}, {*(mValue+4)}, {*(mValue+5)} }}</DisplayString>
    <DisplayString Condition="$T2 &gt; 6">[{$T2}] {{ {*mValue}, {*(mValue+1)}, {*(mValue+2)}, {*(mValue+3)}, {*(mValue+4)}, {*(mValue+5)}, ... }}</DisplayString>
    <Expand>
          <Item Name="[size]">$T2</Item>
          <ArrayItems>
              <Size>$T2</Size>
              <ValuePointer>mValue</ValuePointer>
          </ArrayItems>
      </Expand>
  </Type>

  <Type Name="eastl::basic_string&lt;*&gt;">
    <DisplayString Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">"{($T1*)mPair.mFirst.heap.mpBegin}"</DisplayString>
    <DisplayString Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">"{($T1*)mPair.mFirst.sso.mData}"</DisplayString>
    <Expand>
      <Item Name="[length]"   Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">mPair.mFirst.heap.mnSize</Item>
      <Item Name="[capacity]" Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(mPair.mFirst.heap.mnCapacity &amp; ~kHeapMask)</Item>
      <Item Name="[value]"    Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">($T1*)mPair.mFirst.heap.mpBegin</Item>

      <Item Name="[length]"   Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(int)mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize</Item>
      <Item Name="[capacity]" Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">eastl::string::SSOLayout::SSO_CAPACITY</Item>
      <Item Name="[value]"    Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">($T1*)mPair.mFirst.sso.mData</Item>

      <Item Name="[uses heap]">!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)</Item>
    </Expand>
  </Type>

  <Type Name="eastl::string">
    <DisplayString Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">"{(char*)mPair.mFirst.heap.mpBegin}"</DisplayString>
    <DisplayString Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">"{(char*)mPair.mFirst.sso.mData}"</DisplayString>
    <Expand>
      <Item Name="[length]"   Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">mPair.mFirst.heap.mnSize</Item>
      <Item Name="[capacity]" Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(mPair.mFirst.heap.mnCapacity &amp; ~kHeapMask)</Item>
      <Item Name="[value]"    Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(char*)mPair.mFirst.heap.mpBegin</Item>

      <Item Name="[length]"   Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(int)mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize</Item>
      <Item Name="[capacity]" Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">eastl::string::SSOLayout::SSO_CAPACITY</Item>
      <Item Name="[value]"    Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(char*)mPair.mFirst.sso.mData</Item>

      <Item Name="[uses heap]">!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)</Item>
    </Expand>
  </Type>

  <Type Name="eastl::wstring">
    <DisplayString Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">"{(wchar_t*)mPair.mFirst.heap.mpBegin}"</DisplayString>
    <DisplayString Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">"{(wchar_t*)mPair.mFirst.sso.mData}"</DisplayString>
    <Expand>
      <Item Name="[length]"   Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">mPair.mFirst.heap.mnSize</Item>
      <Item Name="[capacity]" Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(mPair.mFirst.heap.mnCapacity &amp; ~kHeapMask)</Item>
      <Item Name="[value]"    Condition="!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(wchar_t*)mPair.mFirst.heap.mpBegin</Item>

      <Item Name="[length]"   Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize</Item>
      <Item Name="[capacity]" Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">eastl::wstring::SSOLayout::SSO_CAPACITY</Item>
      <Item Name="[value]"    Condition="!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)">(wchar_t*)mPair.mFirst.sso.mData</Item>

      <Item Name="[uses heap]">!!(mPair.mFirst.sso.mRemainingSizeField.mnRemainingSize &amp; kSSOMask)</Item>
    </Expand>
  </Type>

  <Type Name="eastl::pair&lt;*&gt;">
    <DisplayString>({first}, {second})</DisplayString>
      <Expand>
          <Item Name="first">first</Item>
          <Item Name="second">second</Item>
      </Expand>
  </Type>

  <Type Name="eastl::VectorBase&lt;*,*&gt;">
    <DisplayString Condition="mpEnd == mpBegin">[{mpEnd - mpBegin}] {{}}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 1">[{mpEnd - mpBegin}] {{ {*mpBegin} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 2">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 3">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 4">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 5">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)}, {*(mpBegin+4)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 6">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)}, {*(mpBegin+4)}, {*(mpBegin+5)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin &gt; 6">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)}, {*(mpBegin+4)}, {*(mpBegin+5)}, ... }}</DisplayString>
      <Expand>
          <Item Name="[size]">mpEnd - mpBegin</Item>
          <Item Name="[capacity]">mCapacityAllocator.mFirst - mpBegin</Item>
          <ArrayItems>
              <Size>mpEnd - mpBegin</Size>
              <ValuePointer>mpBegin</ValuePointer>
          </ArrayItems>
      </Expand>
  </Type>

  <Type Name="eastl::vector&lt;*&gt;">
    <DisplayString Condition="mpEnd == mpBegin">[{mpEnd - mpBegin}] {{}}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 1">[{mpEnd - mpBegin}] {{ {*mpBegin} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 2">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 3">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 4">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 5">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)}, {*(mpBegin+4)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin == 6">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)}, {*(mpBegin+4)}, {*(mpBegin+5)} }}</DisplayString>
    <DisplayString Condition="mpEnd - mpBegin &gt; 6">[{mpEnd - mpBegin}] {{ {*mpBegin}, {*(mpBegin+1)}, {*(mpBegin+2)}, {*(mpBegin+3)}, {*(mpBegin+4)}, {*(mpBegin+5)}, ... }}</DisplayString>
      <Expand>
          <Item Name="[size]">mpEnd - mpBegin</Item>
          <Item Name="[capacity]">mCapacityAllocator.mFirst - mpBegin</Item>
          <ArrayItems>
              <Size>mpEnd - mpBegin</Size>
              <ValuePointer>mpBegin</ValuePointer>
          </ArrayItems>
      </Expand>
  </Type>
  <Type Name="eastl::DequeBase&lt;*,*,*&gt;">
    <DisplayString Condition="mItBegin.mpCurrent == mItEnd.mpCurrent">
      [0] {{}}
    </DisplayString>
    <DisplayString Condition="(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin) == 1">
      [1] {{ {*mItBegin.mpCurrent} }}
    </DisplayString>
    <DisplayString Condition="(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin) != 0">
      [{(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin)}]
      {{
        {*mItBegin.mpCurrent},
        ...
      }}
    </DisplayString>
    <Expand>
      <Item Name="[size]">(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin)</Item>
      <IndexListItems>
              <Size>(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin)</Size>
              <ValueNode>mItBegin.mpCurrentArrayPtr[(mItBegin.mpCurrent-mItBegin.mpBegin + $i) / $T3][(mItBegin.mpCurrent-mItBegin.mpBegin + $i) % $T3]</ValueNode>
          </IndexListItems>
    </Expand>
  </Type>

  <Type Name="eastl::deque&lt;*,*,*&gt;">
    <DisplayString Condition="mItBegin.mpCurrent == mItEnd.mpCurrent">
      [0] {{}}
    </DisplayString>
    <DisplayString Condition="(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin) == 1">
      [1] {{ {*mItBegin.mpCurrent} }}
    </DisplayString>
    <DisplayString Condition="(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin) != 0">
      [{(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin)}]
      {{
        {*mItBegin.mpCurrent},
        ...
      }}
    </DisplayString>
    <Expand>
      <Item Name="[size]">(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin)</Item>
      <IndexListItems>
              <Size>(mItEnd.mpCurrentArrayPtr - mItBegin.mpCurrentArrayPtr) * $T3 + (mItEnd.mpCurrent-mItEnd.mpBegin) - (mItBegin.mpCurrent-mItBegin.mpBegin)</Size>
              <ValueNode>mItBegin.mpCurrentArrayPtr[(mItBegin.mpCurrent-mItBegin.mpBegin + $i) / $T3][(mItBegin.mpCurrent-mItBegin.mpBegin + $i) % $T3]</ValueNode>
          </IndexListItems>
    </Expand>
  </Type>

  <Type Name="eastl::DequeIterator&lt;*&gt;">
    <DisplayString>{*mpCurrent}</DisplayString>
    <Expand>
      <Item Name="Value">*mpCurrent</Item>
      <Item Name="Previous" Condition="mpCurrent == mpBegin">*(*(mpCurrentArrayPtr-1) + (mpEnd-mpBegin) - 1)</Item>
      <Item Name="Previous" Condition="mpCurrent != mpBegin">*(mpCurrent-1)</Item>
      <Item Name="Next" Condition="mpCurrent+1 == mpEnd">**(mpCurrentArrayPtr+1)</Item>
      <Item Name="Next" Condition="mpCurrent+1 != mpEnd">*(mpCurrent+1)</Item>
      <Item Name="Begin">mpCurrent == mpBegin</Item>
      <Item Name="End">mpCurrent+1 == mpEnd</Item>
    </Expand>
  </Type>

  <Type Name="eastl::queue&lt;*&gt;">
    <AlternativeType Name="eastl::priority_queue&lt;*&gt;" />
    <AlternativeType Name="eastl::stack&lt;*&gt;" />
    <DisplayString>{c}</DisplayString>
    <Expand>
      <ExpandedItem>c</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::list&lt;*&gt;">
    <DisplayString Condition="mNode.mpNext == &amp;mNode">
      [0] {{}}
    </DisplayString>
      <DisplayString Condition="mNode.mpNext != &amp;mNode &amp;&amp; mNode.mpNext-&gt;mpNext == &amp;mNode">
      [1] {{ {((eastl::ListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue} }}
    </DisplayString>
    <DisplayString Condition="mNode.mpNext != &amp;mNode &amp;&amp; mNode.mpNext-&gt;mpNext != &amp;mNode &amp;&amp; mNode.mpNext-&gt;mpNext-&gt;mpNext == &amp;mNode">
      [2]
      {{
        {((eastl::ListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue},
        {((eastl::ListNode&lt;$T1&gt;*)mNode.mpNext-&gt;mpNext)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mNode.mpNext != &amp;mNode &amp;&amp; mNode.mpNext-&gt;mpNext != &amp;mNode &amp;&amp; mNode.mpNext-&gt;mpNext-&gt;mpNext != &amp;mNode">
      [?]
      {{
        {((eastl::ListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue},
        {((eastl::ListNode&lt;$T1&gt;*)mNode.mpNext-&gt;mpNext)-&gt;mValue},
        ...
      }}
    </DisplayString>
    <Expand>
      <Synthetic Name="NOTE!">
        <DisplayString>Content of lists will repeat indefinitely. Keep that in mind!</DisplayString>
      </Synthetic>
          <LinkedListItems>
              <HeadPointer>mNode.mpNext</HeadPointer>
              <NextPointer>mpNext</NextPointer>
              <ValueNode>((eastl::ListNode&lt;$T1&gt;*)this)-&gt;mValue</ValueNode>
          </LinkedListItems>
      </Expand>
  </Type>

  <Type Name="eastl::ListNode&lt;*&gt;">
    <DisplayString>{mValue}</DisplayString>
    <Expand>
      <Item Name="Value">mValue</Item>
      <Item Name="Next">*(eastl::ListNode&lt;$T1&gt;*)mpNext</Item>
      <Item Name="Previous">*(eastl::ListNode&lt;$T1&gt;*)mpPrev</Item>
      <Synthetic Name="NOTE!">
        <DisplayString>Content of lists will repeat indefinitely. Keep that in mind!</DisplayString>
      </Synthetic>
      <Synthetic Name="List">
        <DisplayString>The rest of the list follows:</DisplayString>
      </Synthetic>
          <LinkedListItems>
              <HeadPointer>(eastl::ListNode&lt;$T1&gt;*)mpNext-&gt;mpNext</HeadPointer>
              <NextPointer>(eastl::ListNode&lt;$T1&gt;*)mpNext</NextPointer>
              <ValueNode>mValue</ValueNode>
          </LinkedListItems>
    </Expand>
  </Type>

  <Type Name="eastl::ListIterator&lt;*&gt;">
    <DisplayString>{*mpNode}</DisplayString>
    <Expand>
      <ExpandedItem>mpNode</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::SListBase&lt;*&gt;">
    <DisplayString Condition="mNode.mpNext == 0">
      [0] {{}}
    </DisplayString>
      <DisplayString Condition="mNode.mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext == 0">
      [1]
      {{
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mNode.mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext-&gt;mpNext == 0">
      [2]
      {{
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue},
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext-&gt;mpNext)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mNode.mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext-&gt;mpNext != 0">
      [?]
      {{
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue},
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext-&gt;mpNext)-&gt;mValue},
        ...
      }}
    </DisplayString>
    <Expand>
          <LinkedListItems>
              <HeadPointer>mNode.mpNext</HeadPointer>
              <NextPointer>mpNext</NextPointer>
              <ValueNode>((eastl::SListNode&lt;$T1&gt;*)this)-&gt;mValue</ValueNode>
          </LinkedListItems>
      </Expand>
  </Type>

  <Type Name="eastl::slist&lt;*&gt;">
    <DisplayString Condition="mNode.mpNext == 0">
      [0] {{}}
    </DisplayString>
      <DisplayString Condition="mNode.mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext == 0">
      [1]
      {{
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mNode.mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext-&gt;mpNext == 0">
      [2]
      {{
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue},
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext-&gt;mpNext)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mNode.mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext != 0 &amp;&amp; mNode.mpNext-&gt;mpNext-&gt;mpNext != 0">
      [?]
      {{
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext)-&gt;mValue},
        {((eastl::SListNode&lt;$T1&gt;*)mNode.mpNext-&gt;mpNext)-&gt;mValue},
        ...
      }}
    </DisplayString>
    <Expand>
          <LinkedListItems>
              <HeadPointer>mNode.mpNext</HeadPointer>
              <NextPointer>mpNext</NextPointer>
              <ValueNode>((eastl::SListNode&lt;$T1&gt;*)this)-&gt;mValue</ValueNode>
          </LinkedListItems>
      </Expand>
  </Type>

  <Type Name="eastl::SListNode&lt;*&gt;">
    <DisplayString>{mValue}</DisplayString>
    <Expand>
      <Item Name="Value">mValue</Item>
      <Item Name="Next">*(eastl::SListNode&lt;$T1&gt;*)mpNext</Item>
      <Synthetic Name="List">
        <DisplayString>The rest of the list follows:</DisplayString>
      </Synthetic>
      <LinkedListItems>
              <HeadPointer>mpNext == nullptr ? nullptr : (eastl::SListNode&lt;$T1&gt;*)mpNext-&gt;mpNext</HeadPointer>
              <NextPointer>(eastl::SListNode&lt;$T1&gt;*)mpNext</NextPointer>
              <ValueNode>mValue</ValueNode>
          </LinkedListItems>
    </Expand>
  </Type>

  <Type Name="eastl::SListIterator&lt;*&gt;">
    <DisplayString>{*mpNode}</DisplayString>
    <Expand>
      <ExpandedItem>*mpNode</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::intrusive_list_base">
    <DisplayString Condition="mAnchor.mpNext == &amp;mAnchor">[0] {{}}</DisplayString>
      <DisplayString Condition="mAnchor.mpNext != &amp;mAnchor &amp;&amp; mAnchor.mpNext-&gt;mpNext == &amp;mAnchor">[1] {{ {mAnchor.mpNext} }}</DisplayString>
    <DisplayString Condition="mAnchor.mpNext != &amp;mAnchor &amp;&amp; mAnchor.mpNext-&gt;mpNext != &amp;mAnchor">[?] {{ {mAnchor.mpNext}, ... }}</DisplayString>
    <Expand>
      <Synthetic Name="NOTE!">
        <DisplayString>Content of intrusive lists will repeat indefinitely. Keep that in mind!</DisplayString>
      </Synthetic>
          <LinkedListItems>
              <HeadPointer>mAnchor.mpNext</HeadPointer>
              <NextPointer>mpNext</NextPointer>
              <ValueNode>*this</ValueNode>
          </LinkedListItems>
      </Expand>
  </Type>

  <Type Name="eastl::intrusive_list_iterator&lt;*&gt;">
    <DisplayString>{*mpNode}</DisplayString>
    <Expand>
      <ExpandedItem>*mpNode</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::set&lt;*&gt;">
    <AlternativeType Name="eastl::multiset&lt;*&gt;" />
      <DisplayString Condition="mnSize == 0">
      [0] {{}}
    </DisplayString>
    <DisplayString Condition="mnSize == 1">
      [1]
      {{
        {((eastl::rbtree_node&lt;$T1&gt;*)mAnchor.mpNodeLeft)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mnSize &gt; 1">
      [{mnSize}]
      {{
        {((eastl::rbtree_node&lt;$T1&gt;*)mAnchor.mpNodeLeft)-&gt;mValue},
        ...
      }}
    </DisplayString>
      <Expand>
      <Item Name="[size]">mnSize</Item>
          <TreeItems>
              <Size>mnSize</Size>
              <HeadPointer>mAnchor.mpNodeParent</HeadPointer>
              <LeftPointer>mpNodeLeft</LeftPointer>
              <RightPointer>mpNodeRight</RightPointer>
              <ValueNode>((eastl::rbtree_node&lt;$T1&gt;*)this)-&gt;mValue</ValueNode>
          </TreeItems>
      </Expand>
  </Type>

  <Type Name="eastl::rbtree&lt;*,*&gt;">
    <DisplayString Condition="mnSize == 0">
      [0] {{}}
    </DisplayString>
    <DisplayString Condition="mnSize == 1">
      [1]
      {{
        {((eastl::rbtree_node&lt;$T2&gt;*)mAnchor.mpNodeLeft)-&gt;mValue}
      }}
    </DisplayString>
    <DisplayString Condition="mnSize &gt; 1">
      [{mnSize}]
      {{
        {((eastl::rbtree_node&lt;$T2&gt;*)mAnchor.mpNodeLeft)-&gt;mValue},
        ...
      }}
    </DisplayString>
      <Expand>
      <Item Name="[size]">mnSize</Item>
          <TreeItems>
              <Size>mnSize</Size>
              <HeadPointer>mAnchor.mpNodeParent</HeadPointer>
              <LeftPointer>mpNodeLeft</LeftPointer>
              <RightPointer>mpNodeRight</RightPointer>
              <ValueNode>((eastl::rbtree_node&lt;$T2&gt;*)this)-&gt;mValue</ValueNode>
          </TreeItems>
      </Expand>
  </Type>

  <Type Name="eastl::rbtree_node&lt;*&gt;">
    <DisplayString>{mValue}</DisplayString>
    <Expand>
      <Item Name="Value">mValue</Item>
      <Synthetic Name="NOTE!">
        <DisplayString>It is possible to expand parents that do not exist.</DisplayString>
      </Synthetic>
      <Item Name="Parent">*(eastl::rbtree_node&lt;$T2&gt;*)(mpNodeParent.value &amp; (~uintptr_t(1)))</Item>
      <Item Name="Left">*(eastl::rbtree_node&lt;$T2&gt;*)mpNodeLeft</Item>
      <Item Name="Right">*(eastl::rbtree_node&lt;$T2&gt;*)mpNodeRight</Item>
    </Expand>
  </Type>

  <Type Name="eastl::rbtree_iterator&lt;*&gt;">
    <DisplayString>{*mpNode}</DisplayString>
    <Expand>
      <ExpandedItem>mpNode</ExpandedItem>
    </Expand>
  </Type>


  <Type Name="eastl::hashtable&lt;*&gt;">
      <DisplayString Condition="mnElementCount == 0">[{mnElementCount}] {{}}</DisplayString>
    <DisplayString Condition="mnElementCount != 0">[{mnElementCount}] {{ ... }}</DisplayString>
    <Expand>
      <ArrayItems>
              <Size>mnBucketCount</Size>
              <ValuePointer>mpBucketArray</ValuePointer>
          </ArrayItems>
    </Expand>
  </Type>

  <Type Name="eastl::hash_node&lt;*&gt;">
    <DisplayString Condition="this != 0 &amp;&amp; mpNext != 0"> {mValue}, {*mpNext}</DisplayString>
    <DisplayString Condition="this != 0 &amp;&amp; mpNext == 0"> {mValue}</DisplayString>
    <DisplayString Condition="this == 0"></DisplayString>
    <Expand>
      <LinkedListItems>
              <HeadPointer>this</HeadPointer>
              <NextPointer>mpNext</NextPointer>
              <ValueNode>mValue</ValueNode>
          </LinkedListItems>
    </Expand>
  </Type>

  <Type Name="eastl::hashtable_iterator_base&lt;*&gt;">
    <DisplayString>{mpNode-&gt;mValue}</DisplayString>
    <Expand>
      <ExpandedItem>mpNode-&gt;mValue</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::reverse_iterator&lt;*&gt;">
    <DisplayString>{*(mIterator-1)}</DisplayString>
    <Expand>
      <ExpandedItem>mIterator-1</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::bitset&lt;*&gt;">
    <DisplayString>{{count = {kSize}}}</DisplayString>
    <Expand>
      <Item Name="[count]">kSize</Item>
      <CustomListItems>
        <Variable Name="iWord" InitialValue="0" />
        <Variable Name="iBitInWord" InitialValue="0" />
        <Variable Name="bBitValue" InitialValue="false" />

        <Size>kSize</Size>

        <!--
        <Loop>
          <Exec>bBitValue = ((mWord[iWord] >> iBitInWord) % 2) != 0 ? true : false</Exec>
          <Item>bBitValue</Item>
          <Exec>iBitInWord++</Exec>
          <If Condition="iBitInWord == kBitsPerWord">
            <Exec>iWord++</Exec>
            <Exec>iBitInWord = 0</Exec>
          </If>
        </Loop>
        -->
      </CustomListItems>
    </Expand>
  </Type>

  <Type Name="eastl::ring_buffer&lt;*,*,*&gt;">
    <DisplayString>{c}</DisplayString>
    <Expand>
      <ExpandedItem>c</ExpandedItem>
    </Expand>
  </Type>

  <Type Name="eastl::basic_string_view&lt;*&gt;">
    <DisplayString>{mpBegin,[mnCount]}</DisplayString>
    <StringView>mpBegin,[mnCount]</StringView>
  </Type>

  <Type Name="eastl::string_view">
    <DisplayString>{mpBegin,[mnCount]}</DisplayString>
    <StringView>mpBegin,[mnCount]</StringView>
  </Type>

  <Type Name="eastl::wstring_view">
    <DisplayString>{mpBegin,[mnCount]}</DisplayString>
    <StringView>mpBegin,[mnCount]</StringView>
  </Type>

  <Type Name="eastl::compressed_pair_imp&lt;*&gt;">
    <DisplayString Condition="($T3) == 0" Optional="true">({mFirst}, {mSecond})</DisplayString>
    <DisplayString Condition="($T3) == 1" Optional="true">({mSecond})</DisplayString>
    <DisplayString Condition="($T3) == 2" Optional="true">({mFirst})</DisplayString>
    <DisplayString Condition="($T3) == 3" Optional="true">(empty)</DisplayString>
    <DisplayString Condition="($T3) == 4" Optional="true">(empty)</DisplayString>
    <DisplayString Condition="($T3) == 5" Optional="true">({mFirst}, {mSecond})</DisplayString>
  </Type>

  <Type Name="eastl::optional&lt;*&gt;">
    <!-- <Intrinsic Name="value" Expression="*($T1*)&amp;val"/> -->
    <DisplayString Condition="!engaged">nullopt</DisplayString>
    <DisplayString Condition="engaged">{value()}</DisplayString>
    <Expand>
      <Item Condition="engaged" Name="value">value()</Item>
    </Expand>
  </Type>

  <Type Name="eastl::ratio&lt;*&gt;">
    <DisplayString>{$T1} to {$T2}}</DisplayString>
  </Type>


  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;1,1000000000&gt; &gt;">
    <DisplayString>{mRep} nanoseconds</DisplayString>
  </Type>

  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;1,1000000&gt; &gt;">
    <DisplayString>{mRep} microseconds</DisplayString>
  </Type>

  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;1,1000&gt; &gt;">
    <DisplayString>{mRep} milliseconds</DisplayString>
  </Type>

  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;1,1&gt; &gt;">
    <DisplayString>{mRep} seconds</DisplayString>
  </Type>

  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;60,1&gt; &gt;">
    <DisplayString>{mRep} minutes</DisplayString>
  </Type>

  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;3600,1&gt; &gt;">
    <DisplayString>{mRep} hours</DisplayString>
  </Type>

  <Type Name="eastl::chrono::duration&lt;*,eastl::ratio&lt;*,*&gt; &gt;">
    <DisplayString>{mRep} duration with ratio = [{$T2} : {$T3}] </DisplayString>
  </Type>



  <Type Name="eastl::function&lt;*&gt;">
    <DisplayString Condition="mInvokeFuncPtr == nullptr">empty</DisplayString>
    <DisplayString>{mInvokeFuncPtr}</DisplayString>
  </Type>


  <Type Name="eastl::reference_wrapper&lt;*&gt;">
    <DisplayString>{*val}</DisplayString>
  </Type>

</AutoVisualizer>
