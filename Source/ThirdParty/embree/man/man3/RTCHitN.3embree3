.\" Automatically generated by Pandoc 2.5
.\"
.TH "RTCHitN" "3" "" "" "Embree Ray Tracing Kernels 3"
.hy
.SS NAME
.IP
.nf
\f[C]
RTCHitN \- hit packet of runtime size
\f[R]
.fi
.SS SYNOPSIS
.IP
.nf
\f[C]
#include <embree3/rtcore.h>

struct HitN;

float& RTCHitN_Ng_x(RTCHitN* hit, unsigned int N, unsigned int i);
float& RTCHitN_Ng_y(RTCHitN* hit, unsigned int N, unsigned int i);
float& RTCHitN_Ng_z(RTCHitN* hit, unsigned int N, unsigned int i);

float& RTCHitN_u(RTCHitN* hit, unsigned int N, unsigned int i);
float& RTCHitN_v(RTCHitN* hit, unsigned int N, unsigned int i);

unsigned& RTCHitN_primID(RTCHitN* hit, unsigned int N, unsigned int i);
unsigned& RTCHitN_geomID(RTCHitN* hit, unsigned int N, unsigned int i);
unsigned& RTCHitN_instID(RTCHitN* hit, unsigned int N, unsigned int i, unsigned int level);
\f[R]
.fi
.SS DESCRIPTION
.PP
When the hit packet size is not known at compile time (e.g.\ when Embree
returns a hit packet in the \f[C]RTCFilterFuncN\f[R] callback function),
Embree uses the \f[C]RTCHitN\f[R] type for hit packets.
These hit packets can only have sizes of 1, 4, 8, or 16.
No other packet size will be used.
.PP
You can either implement different special code paths for each of these
possible packet sizes and cast the hit to the appropriate hit packet
type, or implement one general code path that uses the
\f[C]RTCHitN_XXX\f[R] helper functions to access hit packet components.
.PP
These helper functions get a pointer to the hit packet (\f[C]hit\f[R]
argument), the packet size (\f[C]N\f[R] argument), and returns a
reference to a component (e.g.\ x component of \f[C]Ng\f[R]) of the the
i\-th hit of the packet (\f[C]i\f[R] argument).
.SS EXIT STATUS
.SS SEE ALSO
.PP
[RTCRayN]
