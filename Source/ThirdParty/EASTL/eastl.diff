Only in EASTL-master: benchmark
diff -ur EASTL-master/CMakeLists.txt EASTL/CMakeLists.txt
--- EASTL-master/CMakeLists.txt	2020-02-21 10:49:27.838117133 +0200
+++ EASTL/CMakeLists.txt	2020-02-22 10:34:15.614787425 +0200
@@ -2,51 +2,61 @@
 # Copyright (C) Electronic Arts Inc.  All rights reserved.
 #-------------------------------------------------------------------------------------------
 cmake_minimum_required(VERSION 3.1)
-project(EASTL CXX)
+project(EASTL)
 
-#-------------------------------------------------------------------------------------------
-# Options
-#-------------------------------------------------------------------------------------------
-option(EASTL_BUILD_BENCHMARK "Enable generation of build files for benchmark" OFF)
-option(EASTL_BUILD_TESTS "Enable generation of build files for tests" OFF)
-
-#-------------------------------------------------------------------------------------------
-# Compiler Flags
-#-------------------------------------------------------------------------------------------
 set (CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH};${CMAKE_CURRENT_SOURCE_DIR}/scripts/CMake")
 include(CommonCppFlags)
-
-#-------------------------------------------------------------------------------------------
-# Library definition
-#-------------------------------------------------------------------------------------------
-file(GLOB EASTL_SOURCES "source/*.cpp")
-add_library(EASTL ${EASTL_SOURCES})
-
-if(EASTL_BUILD_BENCHMARK)
-    add_subdirectory(benchmark)
-endif()
-
-if(EASTL_BUILD_TESTS)
-    add_subdirectory(test)
-else()
-    add_subdirectory(test/packages/EABase)
+if (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND CMAKE_SIZEOF_VOID_P EQUAL 4 AND
+   (CMAKE_BUILD_TYPE MATCHES "Release" OR CMAKE_BUILD_TYPE MATCHES "MinSizeRel"
+    OR CMAKE_BUILD_TYPE MATCHES "RelWithDebInfo") AND MINGW)
+    message(FATAL_ERROR "FIXME: 32bits mingw-w64 clang crashes when compiling with any optimizations.")
 endif()
 
-#-------------------------------------------------------------------------------------------
-# Defines
-#-------------------------------------------------------------------------------------------
-add_definitions(-D_CHAR16T)
-add_definitions(-D_CRT_SECURE_NO_WARNINGS)
-add_definitions(-D_SCL_SECURE_NO_WARNINGS)
-add_definitions(-DEASTL_OPENSOURCE=1)
-
-#-------------------------------------------------------------------------------------------
-# Include dirs
-#-------------------------------------------------------------------------------------------
-target_include_directories(EASTL PUBLIC include)
-
-#-------------------------------------------------------------------------------------------
-# Dependencies
-#-------------------------------------------------------------------------------------------
-target_link_libraries(EASTL EABase)
-
+file(GLOB_RECURSE EASTL_SOURCES
+    source/*.cpp
+    include/EASTL/*.h
+    test/packages/EAAssert/include/*.h
+    test/packages/EAAssert/include/*.cpp
+    test/packages/EABase/include/*.h
+    test/packages/EAStdC/include/*.h
+    test/packages/EAStdC/source/*.cpp
+)
+
+add_library(EASTL STATIC ${EASTL_SOURCES} ${EASTL_THREAD_SOURCES} doc/EASTL.natvis)
+target_compile_definitions(EASTL
+    PUBLIC  -DEASTL_OPENSOURCE=1
+            -DEASTL_RTTI_ENABLED=0
+            -DEASTL_URHO3D_EXTENSIONS=1
+            -DEASTL_SIZE_T_32BIT=1        # Urho3D uses `unsigned` for sizes all over place. Can not use native size without breaking lots of code.
+            -DEASTDC_THREADING_SUPPORTED=0
+            -DEA_USE_CPP11_CONCURRENCY=1
+            -DEASTDC_GLOBALPTR_SUPPORT_ENABLED=0
+    PRIVATE -D_CHAR16T
+)
+if (MSVC)
+    target_compile_definitions(EASTL PRIVATE -D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS)
+elseif (GCC OR WEB)
+    target_compile_options(EASTL PUBLIC -Wno-literal-suffix)
+endif ()
+
+target_include_directories(EASTL SYSTEM
+    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+           $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/test/packages/EABase/include/Common>
+           $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/test/packages/EAAssert/include>
+           $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/test/packages/EAStdC/include>
+           $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/test/packages/EAThread/include>
+)
+
+if (BUILD_SHARED_LIBS)
+    target_compile_definitions(EASTL PUBLIC -DEASTL_DLL -DEASTDC_DLL PRIVATE -DEASTL_EXPORTS -DEASTDC_EXPORTS)
+endif ()
+
+# Urho3D:
+install (DIRECTORY include/ DESTINATION ${DEST_THIRDPARTY_HEADERS_DIR}/ FILES_MATCHING PATTERN *.h)
+install (DIRECTORY test/packages/EABase/include/Common/ DESTINATION ${DEST_THIRDPARTY_HEADERS_DIR}/ FILES_MATCHING PATTERN *.h)
+install (DIRECTORY test/packages/EAAssert/include/ DESTINATION ${DEST_THIRDPARTY_HEADERS_DIR}/ FILES_MATCHING PATTERN *.h)
+install (DIRECTORY test/packages/EAStdC/include/ DESTINATION ${DEST_THIRDPARTY_HEADERS_DIR}/ FILES_MATCHING PATTERN *.h)
+install (DIRECTORY test/packages/EAThread/include/ DESTINATION ${DEST_THIRDPARTY_HEADERS_DIR}/ FILES_MATCHING PATTERN *.h)
+if (NOT URHO3D_MERGE_STATIC_LIBS)
+    install(TARGETS EASTL EXPORT Urho3D ARCHIVE DESTINATION ${DEST_ARCHIVE_DIR_CONFIG})
+endif ()
Only in EASTL-master: .git
Only in EASTL-master: .gitmodules
diff -ur EASTL-master/include/EASTL/allocator.h EASTL/include/EASTL/allocator.h
--- EASTL-master/include/EASTL/allocator.h	2020-02-21 10:49:27.844783664 +0200
+++ EASTL/include/EASTL/allocator.h	2019-09-14 09:31:32.544800004 +0300
@@ -51,18 +51,19 @@
 	class EASTL_API allocator
 	{
 	public:
-		EASTL_ALLOCATOR_EXPLICIT allocator(const char* pName = EASTL_NAME_VAL(EASTL_ALLOCATOR_DEFAULT_NAME));
-		allocator(const allocator& x);
-		allocator(const allocator& x, const char* pName);
+		// rbfx fix: functions marked as inline to fix excessive warnings.
+		EASTL_ALLOCATOR_EXPLICIT inline allocator(const char* pName = EASTL_NAME_VAL(EASTL_ALLOCATOR_DEFAULT_NAME));
+		inline allocator(const allocator& x);
+		inline allocator(const allocator& x, const char* pName);
 
-		allocator& operator=(const allocator& x);
+		inline allocator& operator=(const allocator& x);
 
-		void* allocate(size_t n, int flags = 0);
-		void* allocate(size_t n, size_t alignment, size_t offset, int flags = 0);
-		void  deallocate(void* p, size_t n);
+		inline void* allocate(size_t n, int flags = 0);
+		inline void* allocate(size_t n, size_t alignment, size_t offset, int flags = 0);
+		inline void  deallocate(void* p, size_t n);
 
-		const char* get_name() const;
-		void        set_name(const char* pName);
+		inline const char* get_name() const;
+		inline void        set_name(const char* pName);
 
 	protected:
 		#if EASTL_NAME_ENABLED
diff -ur EASTL-master/include/EASTL/functional.h EASTL/include/EASTL/functional.h
--- EASTL-master/include/EASTL/functional.h	2020-02-21 10:49:27.848116930 +0200
+++ EASTL/include/EASTL/functional.h	2020-02-22 09:28:21.902118741 +0200
@@ -1006,6 +1006,15 @@
 	///////////////////////////////////////////////////////////////////////
 	// hash
 	///////////////////////////////////////////////////////////////////////
+#if EASTL_URHO3D_EXTENSIONS
+	template <typename T, typename Enable = void> struct hash;
+
+	template <typename T>
+	struct hash<T, typename enable_if<is_enum_v<T>>::type>
+	{
+		size_t operator()(T p) const { return size_t(p); }
+	};
+#else
 	namespace Internal
 	{
 		// utility to disable the generic template specialization that is
@@ -1030,7 +1039,7 @@
 	{
 		size_t operator()(T p) const { return size_t(p); }
 	};
-
+#endif
 	template <typename T> struct hash<T*> // Note that we use the pointer as-is and don't divide by sizeof(T*). This is because the table is of a prime size and this division doesn't benefit distribution.
 		{ size_t operator()(T* p) const { return size_t(uintptr_t(p)); } };
 
diff -ur EASTL-master/include/EASTL/hash_map.h EASTL/include/EASTL/hash_map.h
--- EASTL-master/include/EASTL/hash_map.h	2020-02-21 10:49:27.848116930 +0200
+++ EASTL/include/EASTL/hash_map.h	2020-02-22 09:28:21.902118741 +0200
@@ -285,7 +285,38 @@
 			return (*base_type::DoInsertKey(true_type(), eastl::move(key)).first).second;
 		}
 
+#if EASTL_URHO3D_EXTENSIONS
+		/// Populate the map using variadic template. This handles the base case.
+		this_type& populate(const key_type& key, const mapped_type& value)
+		{
+			this->operator [](key) = value;
+			return *this;
+		}
+
+		/// Populate the map using variadic template.
+		template <typename... Args> this_type& populate(const key_type& key, const mapped_type& value, const Args&... args)
+		{
+			this->operator [](key) = value;
+			return populate(args...);
+		}
+
+		/// Extract values from the map
+		eastl::vector<mapped_type> values() const
+		{
+			eastl::vector<mapped_type> result{};
+			result.reserve(this->size());
+			for (const auto& pair : *this)
+				result.emplace_back(pair.second);
+			return result;
+		}
+
+#ifdef URHO3D_CONTAINER_ADAPTERS
+		using ValueType = mapped_type;
 
+		template <typename... Args> this_type& Populate(const Args&... args) { return populate(args...); }
+		eastl::vector<mapped_type> Values() const { return values(); }
+#endif
+#endif
 	}; // hash_map
 
 	/// hash_map erase_if
diff -ur EASTL-master/include/EASTL/internal/config.h EASTL/include/EASTL/internal/config.h
--- EASTL-master/include/EASTL/internal/config.h	2020-02-21 10:49:27.851450196 +0200
+++ EASTL/include/EASTL/internal/config.h	2020-02-22 09:28:21.902118741 +0200
@@ -289,8 +289,12 @@
 
 #ifndef EASTL_API // If the build file hasn't already defined this to be dllexport...
 	#if EASTL_DLL
-		#if defined(_MSC_VER)
-			#define EASTL_API      __declspec(dllimport)
+		#if defined(_WIN32)
+			#if defined(EASTL_EXPORTS) || defined(URHO3D_EXPORTS)
+				#define EASTL_API      __declspec(dllexport)
+			#else
+				#define EASTL_API      __declspec(dllimport)
+			#endif
 			#define EASTL_LOCAL
 		#elif defined(__CYGWIN__)
 			#define EASTL_API      __attribute__((dllimport))
@@ -316,8 +320,12 @@
 //
 #ifndef EASTL_EASTDC_API
 	#if EASTL_DLL
-		#if defined(_MSC_VER)
-			#define EASTL_EASTDC_API      __declspec(dllimport)
+		#if defined(_WIN32)
+			#if defined(EASTL_EXPORTS) || defined(URHO3D_EXPORTS)
+				#define EASTL_EASTDC_API      __declspec(dllexport)
+			#else
+				#define EASTL_EASTDC_API      __declspec(dllimport)
+			#endif
 			#define EASTL_EASTDC_LOCAL
 		#elif defined(__CYGWIN__)
 			#define EASTL_EASTDC_API      __attribute__((dllimport))
@@ -653,6 +661,9 @@
 			#define EASTL_DEBUG_BREAK() { __asm int 3 }
 		#elif (defined(EA_PROCESSOR_X86) || defined(EA_PROCESSOR_X86_64)) && (defined(EA_ASM_STYLE_ATT) || defined(__GNUC__))
 			#define EASTL_DEBUG_BREAK() asm("int3")
+		#elif defined(EA_PLATFORM_POSIX)
+			#include <signal.h>
+			#define EASTL_DEBUG_BREAK() raise(SIGTRAP)  // Urho3D
 		#else
 			void EASTL_DEBUG_BREAK(); // User must define this externally.
 		#endif
@@ -1873,4 +1884,9 @@
 	#define EASTL_ENABLE_PAIR_FIRST_ELEMENT_CONSTRUCTOR 0
 #endif
 
+
+#if EASTL_URHO3D_EXTENSIONS
+namespace ea = eastl;
+#endif
+
 #endif // Header include guard
diff -ur EASTL-master/include/EASTL/internal/hashtable.h EASTL/include/EASTL/internal/hashtable.h
--- EASTL-master/include/EASTL/internal/hashtable.h	2020-02-21 10:49:27.851450196 +0200
+++ EASTL/include/EASTL/internal/hashtable.h	2019-09-27 14:45:13.665274620 +0300
@@ -43,6 +43,10 @@
 #include <EASTL/tuple.h>
 #include <string.h>
 
+#if EASTL_URHO3D_EXTENSIONS
+	#include <EASTL/vector.h>
+#endif
+
 EA_DISABLE_ALL_VC_WARNINGS()
 	#include <new>
 	#include <stddef.h>
@@ -1172,6 +1176,48 @@
 		bool validate() const;
 		int  validate_iterator(const_iterator i) const;
 
+#if EASTL_URHO3D_EXTENSIONS
+		bool contains(const key_type& key) const
+		{
+			return find(key) != end();
+		}
+
+		eastl::vector<key_type> keys() const
+		{
+			eastl::vector<key_type> result{};
+			result.reserve(size());
+			for (const auto& elem : *this)
+				result.emplace_back(mExtractKey(elem));
+			return result;
+		}
+		
+#ifdef URHO3D_CONTAINER_ADAPTERS
+		using Iterator = iterator;
+		using ConstIterator = const_iterator;
+		using KeyType = key_type;
+
+		size_type Size() const { return size(); }
+		bool Empty() const { return empty(); }
+
+		iterator Begin() { return begin(); }
+		iterator End() { return end(); }
+		const_iterator Begin() const { return begin(); }
+		const_iterator End() const { return end(); }
+
+		iterator Find(const key_type& key) { return find(key); }
+		const_iterator Find(const key_type& key) const { return find(key); }
+		bool Contains(const key_type& key) const { return contains(key); }
+		eastl::vector<key_type> Keys() const { return keys(); }
+
+		iterator Insert(const value_type& value) { return insert(value).first; }
+		bool Erase(const key_type& key) { return erase(key) != 0; }
+		iterator Erase(const_iterator position) { return erase(position); }
+
+		void Rehash(size_type nBucketCount) { rehash(nBucketCount); }
+		void Clear() { clear(); }
+#endif
+#endif
+
 	protected:
 		// We must remove one of the 'DoGetResultIterator' overloads from the overload-set (via SFINAE) because both can
 		// not compile successfully at the same time. The 'bUniqueKeys' template parameter chooses at compile-time the
diff -ur EASTL-master/include/EASTL/internal/red_black_tree.h EASTL/include/EASTL/internal/red_black_tree.h
--- EASTL-master/include/EASTL/internal/red_black_tree.h	2020-02-21 10:49:27.851450196 +0200
+++ EASTL/include/EASTL/internal/red_black_tree.h	2020-02-22 09:28:21.905451960 +0200
@@ -20,6 +20,9 @@
 #include <EASTL/algorithm.h>
 #include <EASTL/initializer_list.h>
 #include <EASTL/tuple.h>
+#if EASTL_URHO3D_EXTENSIONS
+	#include <EASTL/vector.h>
+#endif
 
 EA_DISABLE_ALL_VC_WARNINGS()
 #include <new>
@@ -567,6 +570,30 @@
 		bool validate() const;
 		int  validate_iterator(const_iterator i) const;
 
+#if EASTL_URHO3D_EXTENSIONS
+		bool contains(const key_type& key) const
+		{
+			return find(key) != end();
+		}
+
+		eastl::vector<key_type> keys() const
+		{
+			eastl::vector<key_type> result{};
+			result.reserve(size());
+			for (const auto& pair : *this)
+				result.emplace_back(pair.first);
+			return result;
+		}
+
+		eastl::vector<key_type> values() const
+		{
+			eastl::vector<key_type> result{};
+			result.reserve(size());
+			for (const auto& pair : *this)
+				result.emplace_back(pair.second);
+			return result;
+		}
+#endif
 	protected:
 		node_type* DoAllocateNode();
 		void       DoFreeNode(node_type* pNode);
@@ -621,14 +648,14 @@
 	// rbtree_node_base functions
 	///////////////////////////////////////////////////////////////////////
 
-	EASTL_API inline rbtree_node_base* RBTreeGetMinChild(const rbtree_node_base* pNodeBase)
+	/*rbfx warning fix EASTL_API*/ inline rbtree_node_base* RBTreeGetMinChild(const rbtree_node_base* pNodeBase)
 	{
 		while(pNodeBase->mpNodeLeft) 
 			pNodeBase = pNodeBase->mpNodeLeft;
 		return const_cast<rbtree_node_base*>(pNodeBase);
 	}
 
-	EASTL_API inline rbtree_node_base* RBTreeGetMaxChild(const rbtree_node_base* pNodeBase)
+	/*rbfx warning fix EASTL_API*/ inline rbtree_node_base* RBTreeGetMaxChild(const rbtree_node_base* pNodeBase)
 	{
 		while(pNodeBase->mpNodeRight) 
 			pNodeBase = pNodeBase->mpNodeRight;
diff -ur EASTL-master/include/EASTL/shared_array.h EASTL/include/EASTL/shared_array.h
--- EASTL-master/include/EASTL/shared_array.h	2020-02-21 10:49:27.858116727 +0200
+++ EASTL/include/EASTL/shared_array.h	2019-05-15 09:34:39.690675220 +0300
@@ -361,6 +361,35 @@
 			mAllocator = allocator;
 		}
 
+#if EASTL_URHO3D_EXTENSIONS
+		/// Get pointer to reference count integer. It may be shared between multiple instances of shared_array<>.
+		int* get_refcount_pointer() const
+		{
+			return mpRefCount;
+		}
+
+		/// Perform a static cast from a shared array pointer of another type.
+		template <class U> void do_static_cast(const shared_array<U>& rhs)
+		{
+			this_type().swap(*this);
+			mpArray = static_cast<T*>(rhs.get());
+			mAllocator = rhs.get_allocator();
+			mpRefCount = rhs.get_refcount_pointer();
+			if (mpRefCount != nullptr)
+				++*mpRefCount;
+		}
+
+		/// Perform a reinterpret cast from a shared array pointer of another type.
+		template <class U> void do_reinterpret_cast(const shared_array<U>& rhs)
+		{
+			this_type().swap(*this);
+			mpArray = reinterpret_cast<T*>(rhs.get());
+			mAllocator = rhs.get_allocator();
+			mpRefCount = rhs.get_refcount_pointer();
+			if (mpRefCount != nullptr)
+				++*mpRefCount;
+		}
+#endif
 	}; // class shared_array
 
 
@@ -419,7 +448,23 @@
 		return (sharedArray1.get() < sharedArray2.get()); // Alternatively use: std::less<T*>(a.get(), b.get());
 	}
 
+#if EASTL_URHO3D_EXTENSIONS
+	/// Perform a static cast from one shared array pointer type to another.
+	template <class T, class U> eastl::shared_array<T> do_static_cast(const eastl::shared_array<U>& ptr)
+	{
+		eastl::shared_array<T> ret;
+		ret.StaticCast(ptr);
+		return ret;
+	}
 
+	/// Perform a reinterpret cast from one shared array pointer type to another.
+	template <class T, class U> eastl::shared_array<T> do_reinterpret_cast(const eastl::shared_array<U>& ptr)
+	{
+		eastl::shared_array<T> ret;
+		ret.do_reinterpret_cast(ptr);
+		return ret;
+	}
+#endif
 } // namespace eastl
 
 
diff -ur EASTL-master/include/EASTL/string.h EASTL/include/EASTL/string.h
--- EASTL-master/include/EASTL/string.h	2020-02-21 10:49:27.858116727 +0200
+++ EASTL/include/EASTL/string.h	2020-02-22 09:28:21.905451960 +0200
@@ -132,6 +132,9 @@
 
 #include <EASTL/internal/char_traits.h>
 #include <EASTL/string_view.h>
+#if EASTL_URHO3D_EXTENSIONS
+#include <EASTL/vector.h>
+#endif
 
 ///////////////////////////////////////////////////////////////////////////////
 // EASTL_STRING_EXPLICIT
@@ -748,6 +751,268 @@
 		bool validate() const EA_NOEXCEPT;
 		int  validate_iterator(const_iterator i) const EA_NOEXCEPT;
 
+#if EASTL_URHO3D_EXTENSIONS
+		this_type trimmed() const
+		{
+			this_type result(*this);
+			result.trim();
+			return result;
+		}
+
+		size_type find(view_type x, size_type position = 0) const
+		{
+			return find(x.data(), position, x.length());
+		}
+
+		void replace(value_type old_value, value_type new_value)
+		{
+			eastl::replace(begin(), end(), old_value, new_value);
+		}
+
+		void replace(view_type old_value, view_type new_value)
+		{
+			size_type next = 0;
+			for (size_type start = find(old_value); start != npos; start = find(old_value, next))
+			{
+				replace(begin() + start, begin() + start + old_value.length(), new_value.begin(), new_value.end());
+				next = start + new_value.length();
+			}
+		}
+
+		this_type replaced(value_type old_value, value_type new_value) const
+		{
+			this_type result(*this);
+			result.replace(old_value, new_value);
+			return result;
+		}
+
+		this_type replaced(view_type old_value, view_type new_value) const
+		{
+			this_type result(*this);
+			result.replace(old_value, new_value);
+			return result;
+		}
+
+		static bool comparei_char(value_type c1, value_type c2)
+		{
+			return CharToLower(c1) == CharToLower(c2);
+		}
+
+		bool contains(value_type x, bool caseSensitive = true) const
+		{
+			if (caseSensitive)
+				return find(x) != npos;
+			else
+			{
+				auto predicate = [x](value_type y) { return comparei_char(x, y); };
+				return eastl::find_if(begin(), end(), predicate) != end();
+			}
+		}
+
+		bool contains(view_type x, bool caseSensitive = true) const
+		{
+			if (caseSensitive)
+				return find(x) != npos;
+			else
+				return eastl::search(begin(), end(), x.begin(), x.end(), comparei_char) != end();
+		}
+
+		bool starts_with(const view_type& substring, bool caseSensitive = true) const
+		{
+			if (substring.length() > length())
+				return false;
+			else if (caseSensitive)
+				return compare(begin(), begin() + substring.length(), substring.begin(), substring.end()) == 0;
+			else
+				return comparei(begin(), begin() + substring.length(), substring.begin(), substring.end()) == 0;
+		}
+
+		bool ends_with(const view_type& substring, bool caseSensitive = true) const
+		{
+			if (substring.length() > length())
+				return false;
+			else if (caseSensitive)
+				return compare(end() - substring.length(), end(), substring.begin(), substring.end()) == 0;
+			else
+				return comparei(end() - substring.length(), end(), substring.begin(), substring.end()) == 0;
+		}
+
+		this_type to_lower() const
+		{
+			this_type result(*this);
+			result.make_lower();
+			return result;
+		}
+
+		this_type to_upper() const
+		{
+			this_type result(*this);
+			result.make_upper();
+			return result;
+		}
+
+		static eastl::vector<this_type> split(view_type v, view_type separator, bool keepEmptyStrings = false)
+		{
+			eastl::vector<this_type> ret;
+
+			size_type start = 0;
+			size_type end = v.find(separator);
+			while (end != npos)
+			{
+				view_type token = v.substr(start, end - start);
+				if (keepEmptyStrings || !token.empty())
+					ret.push_back(this_type(token));
+				start = end + separator.length();
+				end = v.find(separator, start);
+			}
+
+			view_type token = v.substr(start, end);
+			if (keepEmptyStrings || !token.empty())
+				ret.push_back(this_type(token));
+
+			return ret;
+		}
+
+		static eastl::vector<this_type> split(view_type v, value_type separator, bool keepEmptyStrings = false)
+		{
+			return split(v, view_type(&separator, 1), keepEmptyStrings);
+		}
+
+		eastl::vector<this_type> split(view_type separator, bool keepEmptyStrings = false) const
+		{
+			return split(*this, separator, keepEmptyStrings);
+		}
+
+		eastl::vector<this_type> split(value_type separator, bool keepEmptyStrings = false) const
+		{
+			return split(*this, separator, keepEmptyStrings);
+		}
+
+		/// Return a string by joining substrings with a 'glue' string.
+		static this_type joined(const eastl::vector<this_type>& subStrings, const this_type& glue)
+		{
+			if (subStrings.empty())
+				return this_type();
+
+			size_type result_size = (subStrings.size() - 1) * glue.length();
+			for (const auto& sub : subStrings)
+				result_size += sub.length();
+
+			this_type joinedString;
+			joinedString.reserve(result_size);
+			joinedString.append(subStrings[0]);
+			for (unsigned i = 1; i < subStrings.size(); ++i)
+				joinedString.append(glue).append(subStrings[i]);
+
+			return joinedString;
+		}
+
+#ifdef URHO3D_CONTAINER_ADAPTERS
+		using Iterator = iterator;
+		using ConstIterator = const_iterator;
+
+		basic_string(value_type x, size_type n) : basic_string(n, x)
+		{
+			static_assert(0, "This constructor is deprecated. "
+				"Change the order of arguments from { character, size } to { size, character }.");
+		}
+
+		explicit basic_string(int value) : basic_string(CtorSprintf(), "%d", value) {}
+		explicit basic_string(unsigned value) : basic_string(CtorSprintf(), "%u", value) {}
+		explicit basic_string(long long value) : basic_string(CtorSprintf(), "%lld", value) {}
+		explicit basic_string(unsigned long long value) : basic_string(CtorSprintf(), "%llu", value) {}
+		explicit basic_string(float value) : basic_string(CtorSprintf(), "%g", value) {}
+		explicit basic_string(double value) : basic_string(CtorSprintf(), "%.15g", value) {}
+		explicit basic_string(bool value) : basic_string(value ? "true" : "false") {}
+		explicit basic_string(char value) : basic_string(1, value) {}
+		
+		size_type Length() const { return size(); }
+		size_type Capacity() const { return capacity(); }
+		bool Empty() const { return empty(); }
+
+		reference At(size_type n) { return (*this)[n]; }
+		const_reference At(size_type n) const { return (*this)[n]; }
+
+		iterator Begin() { return begin(); }
+		iterator End() { return end(); }
+		const_iterator Begin() const { return begin(); }
+		const_iterator End() const { return end(); }
+		reference Front() { return front(); }
+		reference Back() { return back(); }
+		const_reference Front() const { return front(); }
+		const_reference Back() const { return back(); }
+		const_pointer CString() const { return c_str(); }
+
+		void Replace(value_type old_value, value_type new_value) { replace(old_value, new_value); }
+		void Replace(view_type old_value, view_type new_value) { replace(old_value, new_value); }
+		void Replace(size_type position, size_type n, const this_type& x) { replace(position, n, x); }
+		void Replace(size_type position, size_type n, const value_type* x) { replace(position, n, x); }
+		iterator Replace(const_iterator first, const_iterator last, const this_type& x)
+		{
+			size_type pos = first - begin();
+			replace(first, last, x);
+			return begin() + pos;
+		}
+		this_type Replaced(value_type old_value, value_type new_value) const { return replaced(old_value, new_value); }
+		this_type Replaced(view_type old_value, view_type new_value) const { return replaced(old_value, new_value); }
+
+		this_type& Append(const this_type& x) { return append(x); }
+		this_type& Append(const value_type* p) { return append(p); }
+		this_type& Append(const value_type* p, size_type n) { return append(p, n); }
+		this_type& Append(value_type x) { return append(&x, 1); }
+		this_type& AppendWithFormat(const char* pFormat, ...)
+		{
+			va_list args;
+			va_start(args, pFormat);
+			append_sprintf_va_list(pFormat, args);
+			va_end(args);
+			return *this;
+		}
+
+		void Insert(size_type position, const this_type& x) { insert(position, x); }
+		void Insert(size_type position, value_type x) { insert(position, 1, x); }
+		iterator Insert(const_iterator p, const this_type& x) { return insert(p, x.begin(), x.end()); }
+		iterator Insert(const_iterator p, const value_type* pBegin, const value_type* pEnd) { return insert(p, pBegin, pEnd); }
+		iterator Insert(const_iterator p, value_type x) { return insert(p, x); }
+		void Erase(size_type position, size_type n = 1) { erase(position, n); }
+		iterator Erase(const_iterator p) { return erase(p, p + 1); }
+		iterator Erase(const_iterator pBegin, const_iterator pEnd) { return erase(pBegin, pEnd); }
+
+		void Reserve(size_type size) { reserve(size); }
+		void Resize(size_type size) { resize(size); }
+		void Resize(size_type size, value_type value) { resize(size, value); }
+		void Clear() { clear(); }
+		void Compact() { shrink_to_fit(); }
+		void Swap(this_type& other) { swap(other); }
+
+		this_type Substring(size_type position, size_type n = npos) const { return substr(position, n); }
+		this_type Trimmed() const { return trimmed(); }
+		this_type ToUpper() const { return to_upper(); }
+		this_type ToLower() const { return to_lower(); }
+
+		size_type Find(const this_type& x, size_type position = 0) const { return find(x, position); }
+		size_type Find(value_type x, size_type position = 0) const { return find(x, position); }
+		size_type FindLast(const this_type& x, size_type position = npos) const { return rfind(x, position); }
+		size_type FindLast(value_type x, size_type position = npos) const { return rfind(x, position); }
+		bool StartsWith(const this_type& x, bool caseSensitive = true) const { return starts_with(x, caseSensitive); }
+		bool EndsWith(const this_type& x, bool caseSensitive = true) const { return ends_with(x, caseSensitive); }
+		bool Contains(const this_type& x, bool caseSensitive = true) const { return contains(x, caseSensitive); }
+		bool Contains(value_type x, bool caseSensitive = true) const { return contains(x, caseSensitive); }
+
+		eastl::vector<this_type> Split(value_type separator, bool keepEmptyStrings = false) const
+		{
+			return split(separator, keepEmptyStrings);
+		}
+		static eastl::vector<this_type> Split(const value_type* str, value_type separator, bool keepEmptyStrings = false)
+		{
+			return split(str, separator, keepEmptyStrings);
+		}
+		static this_type Joined(const eastl::vector<this_type>& subStrings, const this_type& glue) { return joined(subStrings, glue); }
+
+		static const size_type NPOS = npos;
+		static const this_type EMPTY;
+#endif
+#endif
 
 	protected:
 		// Helper functions for initialization/insertion operations.
@@ -3919,8 +4184,15 @@
 	///    #include <EASTL/hash_set.h>
 	///    hash_set<string> stringHashSet;
 	///
-	template <typename T> struct hash;
+#if EASTL_URHO3D_EXTENSIONS
+#ifdef URHO3D_CONTAINER_ADAPTERS
+	template <typename T, typename Allocator> const basic_string<T, Allocator> basic_string<T, Allocator>::EMPTY;
+#endif
 
+	template <typename T, typename Enable> struct hash;
+#else
+	template <typename T> struct hash;
+#endif
 	template <>
 	struct hash<string>
 	{
diff -ur EASTL-master/include/EASTL/string_view.h EASTL/include/EASTL/string_view.h
--- EASTL-master/include/EASTL/string_view.h	2020-02-21 10:49:27.858116727 +0200
+++ EASTL/include/EASTL/string_view.h	2020-02-22 09:28:21.908785179 +0200
@@ -526,8 +526,11 @@
 	///    #include <EASTL/hash_set.h>
 	///    hash_set<string_view> stringHashSet;
 	///
+#if EASTL_URHO3D_EXTENSIONS
+	template <typename T, typename Enable> struct hash;
+#else
 	template <typename T> struct hash;
-
+#endif
 	template<> struct hash<string_view>
 	{
 		size_t operator()(const string_view& x) const
diff -ur EASTL-master/include/EASTL/utility.h EASTL/include/EASTL/utility.h
--- EASTL-master/include/EASTL/utility.h	2020-02-21 10:49:27.861449992 +0200
+++ EASTL/include/EASTL/utility.h	2020-02-22 09:28:21.908785179 +0200
@@ -81,6 +81,8 @@
 
 		// We declare this version of 'eastl::swap' to make compile-time existance checks for swap functions possible.  
 		//
+		namespace Internal  // Urho3D: this creates ambiguity in some cases
+		{
 		#if EASTL_VARIADIC_TEMPLATES_ENABLED
 			eastl::unused swap(eastl::argument_sink, eastl::argument_sink);
 		#else
@@ -89,10 +91,10 @@
 			// accept the parameters by reference.
 			eastl::unused swap(eastl::argument_sink&, eastl::argument_sink&);
 		#endif
-
+		}
 		template <typename T>
 		struct is_swappable
-			: public integral_constant<bool, !eastl::is_same<decltype(swap(eastl::declval<T&>(), eastl::declval<T&>())), eastl::unused>::value> {}; // Don't prefix swap with eastl:: as we want to allow user-defined swaps via argument-dependent lookup.
+			: public integral_constant<bool, !eastl::is_same<decltype(Internal::swap(eastl::declval<T&>(), eastl::declval<T&>())), eastl::unused>::value> {}; // Don't prefix swap with eastl:: as we want to allow user-defined swaps via argument-dependent lookup.
 	#endif
 	
 	#if EASTL_VARIABLE_TEMPLATES_ENABLED
diff -ur EASTL-master/include/EASTL/vector.h EASTL/include/EASTL/vector.h
--- EASTL-master/include/EASTL/vector.h	2020-02-21 10:49:27.861449992 +0200
+++ EASTL/include/EASTL/vector.h	2020-02-22 09:28:21.908785179 +0200
@@ -312,6 +312,126 @@
 		bool validate() const EA_NOEXCEPT;
 		int  validate_iterator(const_iterator i) const EA_NOEXCEPT;
 
+#if EASTL_URHO3D_EXTENSIONS
+		iterator insert_at(size_type position, const value_type& value)
+		{
+			position = eastl::min(position, size());
+			return insert(begin() + position, value);
+		}
+
+		iterator insert_at(size_type position, value_type&& value)
+		{
+			position = eastl::min(position, size());
+			return insert(begin() + position, eastl::move(value));
+		}
+
+		const_iterator find(const value_type& value) const EA_NOEXCEPT
+		{
+			return eastl::find(cbegin(), cend(), value);
+		}
+
+		iterator find(const value_type& value) EA_NOEXCEPT
+		{
+			return eastl::find(begin(), end(), value);
+		}
+
+		bool contains(const value_type& value) const EA_NOEXCEPT
+		{
+			return find(value) != end();
+		}
+
+		iterator push_front(const value_type& value)
+		{
+			return insert(begin(), value);
+		}
+
+		iterator pop_front()
+		{
+			if (!empty())
+				return erase(begin());
+			return end();
+		}
+
+		iterator erase_at(size_type position)
+		{
+			if (position >= size())
+				return end();
+			return erase(begin() + position);
+		}
+
+		iterator erase_at(size_type position, size_type length)
+		{
+			if (position >= size())
+				return end();
+			length = eastl::min(size() - position, length);
+			return erase(begin() + position, begin() + position + length);
+		}
+
+		size_type index_of(const value_type& value) const
+		{
+			return eastl::distance(cbegin(), find(value));
+		}
+
+		iterator append(const this_type& value)
+		{
+			return insert(end(), value.begin(), value.end());
+		}
+
+#ifdef URHO3D_CONTAINER_ADAPTERS
+		using Iterator = iterator;
+		using ConstIterator = const_iterator;
+
+		vector(const value_type* data, size_type size) : vector(data, data + size) {}
+
+		size_type Size() const { return size(); }
+		size_type Capacity() const { return capacity(); }
+		bool Empty() const { return empty(); }
+
+		reference At(size_type n) { return (*this)[n]; }
+		const_reference At(size_type n) const { return (*this)[n]; }
+
+		iterator Begin() { return begin(); }
+		iterator End() { return end(); }
+		const_iterator Begin() const { return begin(); }
+		const_iterator End() const { return end(); }
+		reference Front() { return front(); }
+		reference Back() { return back(); }
+		const_reference Front() const { return front(); }
+		const_reference Back() const { return back(); }
+		pointer Buffer() { return data(); }
+		const_pointer Buffer() const { return data(); }
+
+		template <class ... Args>
+		reference EmplaceBack(Args&&... args) { return emplace_back(std::forward<Args>(args)...); }
+		void Push(const value_type& value) { push_back(value); }
+		void Push(const this_type& value) { append(value); }
+		void Pop() { pop_back(); }
+
+		void Insert(size_type position, const value_type& value) { insert_at(position, value); }
+		iterator Insert(const_iterator position, const value_type& value) { return insert(position, value); }
+		template <typename InputIterator>
+		iterator Insert(const_iterator position, InputIterator first, InputIterator last) { return insert(position, first, last); }
+
+		void Erase(size_type position, size_type length = 1) { erase_at(position, length); }
+		void EraseSwap(size_type position) { erase_unsorted(begin() + position); }
+
+		iterator Erase(const_iterator position) { return erase(position); }
+		iterator Erase(const_iterator first, const_iterator last) { return erase(first, last); }
+
+		void Reserve(size_type size) { reserve(size); }
+		void Resize(size_type size) { resize(size); }
+		void Resize(size_type size, const value_type& value) { resize(size, value); }
+		void Clear() { clear(); }
+		void Compact() { shrink_to_fit(); }
+		void Swap(this_type& other) { swap(other); }
+
+		iterator Find(const value_type& value) { return find(value); }
+		const_iterator Find(const value_type& value) const { return find(value); }
+		size_type IndexOf(const value_type& value) const { return index_of(value); }
+		bool Contains(const value_type& value) const { return contains(value); }
+#endif
+#endif
+
 	protected:
 		// These functions do the real work of maintaining the vector. You will notice
 		// that many of them have the same name but are specialized on iterator_tag
Only in EASTL-master/scripts: build.sh
Only in EASTL-master/test: CMakeLists.txt
Only in EASTL-master/test/packages/EAAssert: CMakeLists.txt
Only in EASTL-master/test/packages/EAAssert: CONTRIBUTING.md
Only in EASTL-master/test/packages/EAAssert: COPYRIGHT.TXT
Only in EASTL-master/test/packages/EAAssert: doc
Only in EASTL-master/test/packages/EAAssert: .git
Only in EASTL-master/test/packages/EAAssert: .gitignore
Only in EASTL-master/test/packages/EAAssert: .gitmodules
Only in EASTL-master/test/packages/EAAssert: LICENSE
Only in EASTL-master/test/packages/EAAssert: README.md
Only in EASTL-master/test/packages/EAAssert: test
Only in EASTL-master/test/packages/EAAssert: .travis.yml
Only in EASTL-master/test/packages/EABase: CMakeLists.txt
Only in EASTL-master/test/packages/EABase: CONTRIBUTING.md
Only in EASTL-master/test/packages/EABase: doc
Only in EASTL-master/test/packages/EABase: .git
Only in EASTL-master/test/packages/EABase: .gitignore
Only in EASTL-master/test/packages/EABase: .gitmodules
diff -ur EASTL-master/test/packages/EABase/include/Common/EABase/config/eaplatform.h EASTL/test/packages/EABase/include/Common/EABase/config/eaplatform.h
--- EASTL-master/test/packages/EABase/include/Common/EABase/config/eaplatform.h	2020-02-21 10:50:06.077281267 +0200
+++ EASTL/test/packages/EABase/include/Common/EABase/config/eaplatform.h	2020-02-22 10:00:45.000000000 +0200
@@ -615,6 +615,17 @@
 // __sun is defined by the GCC compiler.
 // __i386 is defined by the Sun and GCC compilers.
 // __sparc is defined by the Sun and GCC compilers.
+#elif defined(__EMSCRIPTEN__)   // Urho3D
+	#undef  EA_PLATFORM_WEB
+	#define EA_PLATFORM_WEB 1
+	#define EA_PLATFORM_UNIX 0
+	#define EA_PLATFORM_POSIX 1
+	#define EA_PLATFORM_NAME "Web"
+	#define EA_PLATFORM_DESCRIPTION "Web (Emscritpten)"
+	#define EA_ASM_STYLE_ATT 1
+	#define EA_SYSTEM_LITTLE_ENDIAN 1
+	#define EA_POSIX_THREADS_AVAILABLE 0
+	#define EA_PROCESSOR_WASM 1
 #else
 	#error Unknown platform
 	#error Unknown processor
diff -ur EASTL-master/test/packages/EABase/include/Common/EABase/eabase.h EASTL/test/packages/EABase/include/Common/EABase/eabase.h
--- EASTL-master/test/packages/EABase/include/Common/EABase/eabase.h	2020-02-21 10:50:06.080614525 +0200
+++ EASTL/test/packages/EABase/include/Common/EABase/eabase.h	2020-02-22 09:28:21.912118398 +0200
@@ -727,11 +727,12 @@
 
 #ifndef CHAR8_T_DEFINED // If the user hasn't already defined these...
 	#define CHAR8_T_DEFINED
-	#if defined(EA_PLATFORM_APPLE)
-		#define char8_t char    // The Apple debugger is too stupid to realize char8_t is typedef'd to char, so we #define it.
-	#else
+	// rbfx: This breaks fmt and is wrong in general. Library that implements missing types should put them in internal namespace like fmt does.
+	// #if defined(EA_PLATFORM_APPLE)
+	// 	#define char8_t char    // The Apple debugger is too stupid to realize char8_t is typedef'd to char, so we #define it.
+	// #else
 		typedef char char8_t;
-	#endif
+	// #endif
 	
 	#if EA_CHAR16_NATIVE
 		// In C++, char16_t and char32_t are already defined by the compiler.
Only in EASTL-master/test/packages/EABase: LICENSE
Only in EASTL-master/test/packages/EABase: .p4ignore
Only in EASTL-master/test/packages/EABase: README.md
Only in EASTL-master/test/packages/EABase: test
Only in EASTL-master/test/packages/EABase: .travis.yml
Only in EASTL-master/test/packages: EAMain
Only in EASTL-master/test/packages/EAStdC: CMakeLists.txt
Only in EASTL-master/test/packages/EAStdC: CONTRIBUTING.md
Only in EASTL-master/test/packages/EAStdC: doc
Only in EASTL-master/test/packages/EAStdC: .git
Only in EASTL-master/test/packages/EAStdC: .gitignore
Only in EASTL-master/test/packages/EAStdC: .gitmodules
diff -ur EASTL-master/test/packages/EAStdC/include/EAStdC/EAStopwatch.h EASTL/test/packages/EAStdC/include/EAStdC/EAStopwatch.h
--- EASTL-master/test/packages/EAStdC/include/EAStdC/EAStopwatch.h	2020-02-21 10:50:06.143946433 +0200
+++ EASTL/test/packages/EAStdC/include/EAStdC/EAStopwatch.h	2020-02-22 09:28:21.912118398 +0200
@@ -643,7 +643,7 @@
 	// You can disable usage of QueryPerformanceCounter below by defining
 	// EASTDC_STOPWATCH_FORCE_CPU_CYCLE_USAGE as 1.
 	// hardcode prototype here so we don't pull in <windows.h>
-	extern "C" __declspec(dllimport) int __stdcall QueryPerformanceCounter(_Out_ union _LARGE_INTEGER *lpPerformanceCount);
+	extern "C" __declspec(dllimport) int __stdcall QueryPerformanceCounter(union _LARGE_INTEGER *lpPerformanceCount);   // Urho3D: _Out_ is not defined on MinGW
 
 	inline uint64_t EA::StdC::Stopwatch::GetStopwatchCycle()
 	{
diff -ur EASTL-master/test/packages/EAStdC/include/EAStdC/internal/Config.h EASTL/test/packages/EAStdC/include/EAStdC/internal/Config.h
--- EASTL-master/test/packages/EAStdC/include/EAStdC/internal/Config.h	2020-02-21 10:50:06.143946433 +0200
+++ EASTL/test/packages/EAStdC/include/EAStdC/internal/Config.h	2020-02-22 10:15:29.744791597 +0200
@@ -149,9 +149,13 @@
 // For GCC, see http://gcc.gnu.org/wiki/Visibility
 //
 #ifndef EASTDC_API // If the build file hasn't already defined this to be dllexport...
-	#if EASTDC_DLL 
-		#if defined(_MSC_VER)
-			#define EASTDC_API      __declspec(dllimport)
+	#if EASTDC_DLL
+		#if defined(_WIN32)
+			#if defined(EASTDC_EXPORTS) || defined(URHO3D_EXPORTS)
+				#define EASTDC_API      __declspec(dllexport)
+			#else
+				#define EASTDC_API      __declspec(dllimport)
+			#endif
 			#define EASTDC_LOCAL
 		#elif defined(__CYGWIN__)
 			#define EASTDC_API      __attribute__((dllimport))
Only in EASTL-master/test/packages/EAStdC: LICENSE
Only in EASTL-master/test/packages/EAStdC: README.md
Only in EASTL-master/test/packages/EAStdC: test
Only in EASTL-master/test/packages/EAStdC: .travis.yml
Only in EASTL-master/test/packages: EATest
Only in EASTL-master/test/packages/EAThread: 3RDPARTYLICENSES.TXT
Only in EASTL-master/test/packages/EAThread: CMakeLists.txt
Only in EASTL-master/test/packages/EAThread: CONTRIBUTING.md
Only in EASTL-master/test/packages/EAThread: doc
Only in EASTL-master/test/packages/EAThread: .git
Only in EASTL-master/test/packages/EAThread: .gitignore
Only in EASTL-master/test/packages/EAThread: .gitmodules
diff -ur EASTL-master/test/packages/EAThread/include/eathread/eathread_atomic.h EASTL/test/packages/EAThread/include/eathread/eathread_atomic.h
--- EASTL-master/test/packages/EAThread/include/eathread/eathread_atomic.h	2020-02-21 10:50:06.217278116 +0200
+++ EASTL/test/packages/EAThread/include/eathread/eathread_atomic.h	2020-02-22 09:28:21.918784836 +0200
@@ -30,12 +30,13 @@
 #include <eathread/eathread.h>
 #include <eathread/eathread_sync.h>
 
-
-#if !EA_THREADS_AVAILABLE
-	// Do nothing. Let the default implementation below be used.
-//#elif defined(EA_USE_CPP11_CONCURRENCY) && EA_USE_CPP11_CONCURRENCY
-//    #include <eathread/cpp11/eathread_atomic_cpp11.h> // CPP11 atomics are currently broken and slow.  To be renabled for other platforms when VS2013 released.
-#elif defined(EA_USE_COMMON_ATOMICINT_IMPLEMENTATION) && EA_USE_COMMON_ATOMICINT_IMPLEMENTATION
+// Urho3D: Atomics are needed regardless of threading availability
+// #if !EA_THREADS_AVAILABLE
+// 	// Do nothing. Let the default implementation below be used.
+// //#elif defined(EA_USE_CPP11_CONCURRENCY) && EA_USE_CPP11_CONCURRENCY
+// //    #include <eathread/cpp11/eathread_atomic_cpp11.h> // CPP11 atomics are currently broken and slow.  To be renabled for other platforms when VS2013 released.
+// #el
+#if defined(EA_USE_COMMON_ATOMICINT_IMPLEMENTATION) && EA_USE_COMMON_ATOMICINT_IMPLEMENTATION
 	#include <eathread/internal/eathread_atomic.h>
 #elif defined(EA_PLATFORM_APPLE)
 	#include <eathread/apple/eathread_atomic_apple.h>
diff -ur EASTL-master/test/packages/EAThread/include/eathread/eathread_futex.h EASTL/test/packages/EAThread/include/eathread/eathread_futex.h
--- EASTL-master/test/packages/EAThread/include/eathread/eathread_futex.h	2020-02-21 10:50:06.217278116 +0200
+++ EASTL/test/packages/EAThread/include/eathread/eathread_futex.h	2020-02-22 09:28:21.918784836 +0200
@@ -102,13 +102,13 @@
 		{
 			#if defined(EA_COMPILER_GNUC)
 				// Mingw declares these slightly differently.
-				struct _CRITICAL_SECTION;
-				__declspec(dllimport) int           __stdcall InitializeCriticalSectionAndSpinCount(_CRITICAL_SECTION* pCriticalSection, unsigned long dwSpinCount);
-				__declspec(dllimport) void          __stdcall InitializeCriticalSection(_CRITICAL_SECTION* pCriticalSection);
-				__declspec(dllimport) void          __stdcall DeleteCriticalSection(_CRITICAL_SECTION* pCriticalSection);
-				__declspec(dllimport) void          __stdcall EnterCriticalSection(_CRITICAL_SECTION* pCriticalSection);
-				__declspec(dllimport) void          __stdcall LeaveCriticalSection(_CRITICAL_SECTION* pCriticalSection);
-				__declspec(dllimport) int           __stdcall TryEnterCriticalSection(_CRITICAL_SECTION* pCriticalSection);
+				struct _RTL_CRITICAL_SECTION;   // Urho3D
+				__declspec(dllimport) int           __stdcall InitializeCriticalSectionAndSpinCount(_RTL_CRITICAL_SECTION* pCriticalSection, unsigned long dwSpinCount);
+				__declspec(dllimport) void          __stdcall InitializeCriticalSection(_RTL_CRITICAL_SECTION* pCriticalSection);
+				__declspec(dllimport) void          __stdcall DeleteCriticalSection(_RTL_CRITICAL_SECTION* pCriticalSection);
+				__declspec(dllimport) void          __stdcall EnterCriticalSection(_RTL_CRITICAL_SECTION* pCriticalSection);
+				__declspec(dllimport) void          __stdcall LeaveCriticalSection(_RTL_CRITICAL_SECTION* pCriticalSection);
+				__declspec(dllimport) int           __stdcall TryEnterCriticalSection(_RTL_CRITICAL_SECTION* pCriticalSection);
 			#else
 				#if !defined _Must_inspect_result_ 
 					#define _Must_inspect_result_
diff -ur EASTL-master/test/packages/EAThread/include/eathread/internal/config.h EASTL/test/packages/EAThread/include/eathread/internal/config.h
--- EASTL-master/test/packages/EAThread/include/eathread/internal/config.h	2020-02-21 10:50:06.220611374 +0200
+++ EASTL/test/packages/EAThread/include/eathread/internal/config.h	2020-02-22 10:16:07.797416926 +0200
@@ -335,8 +335,15 @@
 // For GCC, see http://gcc.gnu.org/wiki/Visibility
 //
 #ifndef EATHREADLIB_API // If the build file hasn't already defined this to be dllexport...
-	#if EATHREAD_DLL 
-		#if defined(_MSC_VER)
+	#if EATHREAD_DLL
+		#if defined(_WIN32)
+			#if defined(EATHREAD_EXPORTS) || defined(URHO3D_EXPORTS)    // Urho3D
+				#define EATHREADLIB_API      __declspec(dllexport)
+			#else
+				#define EATHREADLIB_API      __declspec(dllimport)
+			#endif
+			#define EATHREADLIB_LOCAL
+                #elif defined(_MSC_VER)
 			#define EATHREADLIB_API      __declspec(dllimport)
 			#define EATHREADLIB_LOCAL
 		#elif defined(__CYGWIN__)
Only in EASTL-master/test/packages/EAThread: LICENSE
Only in EASTL-master/test/packages/EAThread: .p4ignore
Only in EASTL-master/test/packages/EAThread: README.md
diff -ur EASTL-master/test/packages/EAThread/source/android/eathread_fake_atomic_64.cpp EASTL/test/packages/EAThread/source/android/eathread_fake_atomic_64.cpp
--- EASTL-master/test/packages/EAThread/source/android/eathread_fake_atomic_64.cpp	2020-02-21 10:50:06.223944632 +0200
+++ EASTL/test/packages/EAThread/source/android/eathread_fake_atomic_64.cpp	2020-02-22 09:28:21.922118056 +0200
@@ -27,8 +27,8 @@
 
 #define EAT_FAKE_ATOMIC_SWAP_LOCK_COUNT 32U
 static pthread_mutex_t sFakeAtomic64SwapLocks[EAT_FAKE_ATOMIC_SWAP_LOCK_COUNT];
-
-#define EAT_SWAP_LOCK(addr) &sFakeAtomic64SwapLocks[((unsigned)(void*)(addr) >> 3U) % EAT_FAKE_ATOMIC_SWAP_LOCK_COUNT]
+// Urho3D: unsigned -> int64_t to fix build error on 64bit android
+#define EAT_SWAP_LOCK(addr) &sFakeAtomic64SwapLocks[((int64_t)(void*)(addr) >> 3U) % EAT_FAKE_ATOMIC_SWAP_LOCK_COUNT]
 
 
 int64_t android_fake_atomic_swap_64(int64_t value, volatile int64_t* addr)
Only in EASTL-master/test/packages/EAThread: test
Only in EASTL-master/test/packages/EAThread: .travis.yml
Only in EASTL-master/test/source: ConceptImpls.h
Only in EASTL-master/test/source: EASTLTestAllocator.cpp
Only in EASTL-master/test/source: EASTLTest.h
Only in EASTL-master/test/source: main.cpp
Only in EASTL-master/test/source: TestAlgorithm.cpp
Only in EASTL-master/test/source: TestAny.cpp
Only in EASTL-master/test/source: TestArray.cpp
Only in EASTL-master/test/source: TestBitVector.cpp
Only in EASTL-master/test/source: TestDeque.cpp
Only in EASTL-master/test/source: TestExtra.cpp
Only in EASTL-master/test/source: TestFinally.cpp
Only in EASTL-master/test/source: TestFixedFunction.cpp
Only in EASTL-master/test/source: TestFixedString.cpp
Only in EASTL-master/test/source: TestFixedVector.cpp
Only in EASTL-master/test/source: TestFunctional.cpp
Only in EASTL-master/test/source: TestHash.cpp
Only in EASTL-master/test/source: TestIntrusiveSDList.cpp
Only in EASTL-master/test/source: TestIterator.cpp
Only in EASTL-master/test/source: TestList.cpp
Only in EASTL-master/test/source: TestLruCache.cpp
Only in EASTL-master/test/source: TestMap.cpp
Only in EASTL-master/test/source: TestOptional.cpp
Only in EASTL-master/test/source: TestSegmentedVector.cpp
Only in EASTL-master/test/source: TestSet.cpp
Only in EASTL-master/test/source: TestSList.cpp
Only in EASTL-master/test/source: TestSmartPtr.cpp
Only in EASTL-master/test/source: TestSort.cpp
Only in EASTL-master/test/source: TestSpan.cpp
Only in EASTL-master/test/source: TestString.cpp
Only in EASTL-master/test/source: TestStringHashMap.cpp
Only in EASTL-master/test/source: TestString.inl
Only in EASTL-master/test/source: TestStringView.cpp
Only in EASTL-master/test/source: TestStringView.inl
Only in EASTL-master/test/source: TestUtility.cpp
Only in EASTL-master/test/source: TestVariant.cpp
Only in EASTL-master/test/source: TestVector.cpp
Only in EASTL-master/test/source: TestVectorMap.cpp
Only in EASTL-master/test/source: TestVectorSet.cpp
Only in EASTL-master: .travis.yml
